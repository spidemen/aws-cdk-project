"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkelTree = exports.Node = void 0;
const { Keccak } = require('sha3');
class Node {
    constructor(index, level, offset) {
        this.hash = new Keccak(256);
        this.index = index;
        this.level = level;
        this.offset = offset;
        this.isLeave = false;
        this.hashVal = "";
    }
    ComputeHashVal() {
        if (this.hashVal == "") {
            if (this.isLeave) {
                // index + level + offset will be unique in the tree
                // so use those three concrat string
                let nodeMetaData = String(this.index) + ":" + String(this.level) + ":" + String(this.offset);
                this.hash.update(nodeMetaData);
                this.hashVal = this.hash.digest('hex');
            }
            else {
                if (this.leftChild != undefined || this.rightChild != undefined) {
                    this.hash.update(this.leftChild.hashVal || this.rightChild.hashVal);
                    this.hashVal = this.hash.digest('hex');
                }
            }
        }
        return this.hashVal;
    }
}
exports.Node = Node;
class MerkelTree {
    constructor() {
        // <index, Node object>
        this.indexMp = new Map();
    }
    static getInstance() {
        if (!MerkelTree.instance) {
            MerkelTree.instance = new MerkelTree();
        }
        return MerkelTree.instance;
    }
    // by defition, deepest level nodes are all leave node
    // full binary tree, start contract from leave node all the way to root
    // level by level
    buildTree(treeData) {
        let levelMp = new Map();
        let maxLevel = 0;
        let arr = treeData.split("&");
        arr.forEach((element) => {
            let nums = element.replace('[', '').replace(']', '').split(',');
            // input are always int 
            let level = Number(nums[1]);
            let node = new Node(Number(nums[0]), level, Number(nums[2]));
            if (maxLevel < level) {
                maxLevel = level;
            }
            let nodeArr = new Array();
            nodeArr.push(node);
            let nodeArr2 = levelMp.get(level);
            if (nodeArr2 == undefined) {
                levelMp.set(level, nodeArr);
            }
            else {
                let nodeArr3 = nodeArr2.concat(nodeArr);
                nodeArr3.sort((a, b) => (a.offset > b.offset ? 1 : -1));
                levelMp.set(level, nodeArr3);
            }
        });
        // construct tree
        for (let i = maxLevel; i > 0; i--) {
            let rootNodes = levelMp.get(i - 1);
            let childNodes = levelMp.get(i);
            rootNodes != undefined && rootNodes.forEach(root => {
                if (childNodes != undefined) {
                    root.leftChild = childNodes[root.offset * 2];
                    root.rightChild = childNodes[root.offset * 2 + 1];
                    if (i == maxLevel) {
                        // update leave node prop
                        root.leftChild.isLeave = true;
                        root.leftChild.ComputeHashVal();
                        this.indexMp.set(root.leftChild.index, root.leftChild);
                        if (root.rightChild != undefined) {
                            // not single leave
                            root.rightChild.isLeave = true;
                            root.rightChild.ComputeHashVal();
                            this.indexMp.set(root.rightChild.index, root.rightChild);
                        }
                    }
                    root.ComputeHashVal();
                    this.indexMp.set(root.index, root);
                }
            });
        }
        let defaultRoot = this.indexMp.get(0);
        if (defaultRoot != undefined) {
            this.root = defaultRoot;
        }
        else {
            // create fake root
            this.root = new Node(-1, -1, -1);
        }
        // output whole tree
        console.log(this.root);
        return this.root;
    }
    query(index) {
        let node = this.indexMp.get(index);
        if (node == undefined) {
            return new Node(-1, -1, -1);
        }
        return node;
    }
}
exports.MerkelTree = MerkelTree;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVya2VsVHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1lcmtlbFRyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUVuQyxNQUFhLElBQUk7SUFjYixZQUFhLEtBQVksRUFBRSxLQUFhLEVBQUUsTUFBYztRQUgvQyxTQUFJLEdBQUcsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFJNUIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVNLGNBQWM7UUFFakIsSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLEVBQUUsRUFBRTtZQUNwQixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ2Qsb0RBQW9EO2dCQUNwRCxvQ0FBb0M7Z0JBQ3BDLElBQUksWUFBWSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzdGLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUMvQixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzFDO2lCQUFNO2dCQUNILElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxTQUFTLElBQUksSUFBSSxDQUFDLFVBQVUsSUFB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QUMsQ0FBQztTQUNOO1FBQ0QsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEMsSUFBSSxXQUFXLElBQUksU0FBUyxFQUFFO1lBQzNCLElBQUksQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDO1NBQzFCO2FBQU07WUFDSCxtQkFBbUI7WUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2xDO1FBRUQsb0JBQW9CO1FBQ3BCLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztJQUdyQixDQUFDO0lBRU0sS0FBSyxDQUFFLEtBQWE7UUFDdkIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbkMsSUFBSSxJQUFJLElBQUksU0FBUyxFQUFFO1lBQ25CLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM3QjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Q0FDSjtBQTNGRCxnQ0EyRkMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IHsgS2VjY2FrIH0gPSByZXF1aXJlKCdzaGEzJyk7XG5cbmV4cG9ydCBjbGFzcyBOb2RlIHtcbiAgICBwdWJsaWMgaW5kZXg6IG51bWJlcjtcbiAgICBwdWJsaWMgbGV2ZWw6IG51bWJlcjtcbiAgICBwdWJsaWMgb2Zmc2V0OiBudW1iZXI7XG4gICAgcHVibGljIGhhc2hWYWw6IHN0cmluZztcblxuICAgIHB1YmxpYyBwYXJlbnQ6IE5vZGU7XG4gICAgcHVibGljIGxlZnRDaGlsZDogTm9kZTtcbiAgICBwdWJsaWMgcmlnaHRDaGlsZDogTm9kZTtcbiAgICBwdWJsaWMgaXNMZWF2ZTogYm9vbGVhbjtcblxuICAgIHByaXZhdGUgIGhhc2ggPSBuZXcgS2VjY2FrKDI1Nik7XG5cblxuICAgIGNvbnN0cnVjdG9yIChpbmRleDpudW1iZXIsIGxldmVsOiBudW1iZXIsIG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xlYXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzaFZhbCA9IFwiXCI7XG4gICAgfVxuXG4gICAgcHVibGljIENvbXB1dGVIYXNoVmFsKCkge1xuXG4gICAgICAgIGlmICh0aGlzLmhhc2hWYWwgPT0gXCJcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMZWF2ZSkge1xuICAgICAgICAgICAgICAgIC8vIGluZGV4ICsgbGV2ZWwgKyBvZmZzZXQgd2lsbCBiZSB1bmlxdWUgaW4gdGhlIHRyZWVcbiAgICAgICAgICAgICAgICAvLyBzbyB1c2UgdGhvc2UgdGhyZWUgY29uY3JhdCBzdHJpbmdcbiAgICAgICAgICAgICAgICBsZXQgbm9kZU1ldGFEYXRhID0gU3RyaW5nKHRoaXMuaW5kZXgpICsgXCI6XCIgKyBTdHJpbmcodGhpcy5sZXZlbCkgKyBcIjpcIiArIFN0cmluZyh0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNoLnVwZGF0ZShub2RlTWV0YURhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzaFZhbCA9IHRoaXMuaGFzaC5kaWdlc3QoJ2hleCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWZ0Q2hpbGQgIT0gdW5kZWZpbmVkIHx8IHRoaXMucmlnaHRDaGlsZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNoLnVwZGF0ZSh0aGlzLmxlZnRDaGlsZC5oYXNoVmFsIHx8IHRoaXMucmlnaHRDaGlsZC5oYXNoVmFsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNoVmFsID0gdGhpcy5oYXNoLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICByZXR1cm4gdGhpcy5oYXNoVmFsO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1lcmtlbFRyZWUge1xuICAgIHB1YmxpYyBzdGF0aWMgaW5zdGFuY2U6IE1lcmtlbFRyZWU7XG4gICAgXG4gICAgLy8gPGluZGV4LCBOb2RlIG9iamVjdD5cbiAgICBwcml2YXRlIGluZGV4TXAgPSBuZXcgTWFwPG51bWJlciwgTm9kZT4oKTtcblxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7IH1cblxuICAgIHB1YmxpYyByb290IDogTm9kZTtcbiAgICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IE1lcmtlbFRyZWUge1xuICAgICAgICBpZiAoIU1lcmtlbFRyZWUuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIE1lcmtlbFRyZWUuaW5zdGFuY2UgPSBuZXcgTWVya2VsVHJlZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE1lcmtlbFRyZWUuaW5zdGFuY2U7XG4gICAgfVxuICAgIC8vIGJ5IGRlZml0aW9uLCBkZWVwZXN0IGxldmVsIG5vZGVzIGFyZSBhbGwgbGVhdmUgbm9kZVxuICAgIC8vIGZ1bGwgYmluYXJ5IHRyZWUsIHN0YXJ0IGNvbnRyYWN0IGZyb20gbGVhdmUgbm9kZSBhbGwgdGhlIHdheSB0byByb290XG4gICAgLy8gbGV2ZWwgYnkgbGV2ZWxcbiAgICBwdWJsaWMgYnVpbGRUcmVlKHRyZWVEYXRhOiBzdHJpbmcpIHtcbiAgICAgICAgbGV0IGxldmVsTXAgPSBuZXcgTWFwPG51bWJlciwgTm9kZVtdPigpO1xuICAgICAgICBsZXQgbWF4TGV2ZWwgPSAwO1xuICAgICAgICBsZXQgYXJyID0gdHJlZURhdGEuc3BsaXQoXCImXCIpOyAgICBcbiAgICAgICAgYXJyLmZvckVhY2goIChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgbnVtcyA9IGVsZW1lbnQucmVwbGFjZSgnWycsJycpLnJlcGxhY2UoJ10nLCcnKS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgLy8gaW5wdXQgYXJlIGFsd2F5cyBpbnQgXG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSBOdW1iZXIobnVtc1sxXSk7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IG5ldyBOb2RlKE51bWJlcihudW1zWzBdKSxsZXZlbCwgTnVtYmVyKG51bXNbMl0pKTtcbiAgICAgICAgICAgIGlmICggbWF4TGV2ZWwgPCBsZXZlbCkge1xuICAgICAgICAgICAgICAgIG1heExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbm9kZUFycjogTm9kZVtdID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICBub2RlQXJyLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBsZXQgbm9kZUFycjIgPSBsZXZlbE1wLmdldChsZXZlbCk7XG4gICAgICAgICAgICBpZiAobm9kZUFycjIgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWxNcC5zZXQobGV2ZWwsIG5vZGVBcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZUFycjMgPSBub2RlQXJyMi5jb25jYXQobm9kZUFycik7XG4gICAgICAgICAgICAgICAgbm9kZUFycjMuc29ydCgoIGEsIGIgKSA9PiAoYS5vZmZzZXQgPiBiLm9mZnNldCA/IDEgOiAtMSkpOyBcbiAgICAgICAgICAgICAgICBsZXZlbE1wLnNldChsZXZlbCwgbm9kZUFycjMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTsgIFxuICAgICAgICBcbiAgICAgICAgLy8gY29uc3RydWN0IHRyZWVcbiAgICAgICAgZm9yIChsZXQgaSA9IG1heExldmVsOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgcm9vdE5vZGVzID0gbGV2ZWxNcC5nZXQoaS0xKTtcbiAgICAgICAgICAgIGxldCBjaGlsZE5vZGVzID0gbGV2ZWxNcC5nZXQoaSk7XG4gICAgICAgICAgICByb290Tm9kZXMgIT0gdW5kZWZpbmVkICYmIHJvb3ROb2Rlcy5mb3JFYWNoKHJvb3QgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgIHJvb3QubGVmdENoaWxkID0gIGNoaWxkTm9kZXNbcm9vdC5vZmZzZXQgKiAyXTtcbiAgICAgICAgICAgICAgICAgICByb290LnJpZ2h0Q2hpbGQgPSAgY2hpbGROb2Rlc1tyb290Lm9mZnNldCAqIDIgKyAxXTtcbiAgICAgICAgICAgICAgICAgICBpZiAoIGkgID09IG1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBsZWF2ZSBub2RlIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICByb290LmxlZnRDaGlsZC5pc0xlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICByb290LmxlZnRDaGlsZC5Db21wdXRlSGFzaFZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNcC5zZXQocm9vdC5sZWZ0Q2hpbGQuaW5kZXgsIHJvb3QubGVmdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocm9vdC5yaWdodENoaWxkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IHNpbmdsZSBsZWF2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5yaWdodENoaWxkLmlzTGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5yaWdodENoaWxkLkNvbXB1dGVIYXNoVmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4TXAuc2V0KHJvb3QucmlnaHRDaGlsZC5pbmRleCwgcm9vdC5yaWdodENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgIHJvb3QuQ29tcHV0ZUhhc2hWYWwoKTsgXG4gICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNcC5zZXQocm9vdC5pbmRleCwgcm9vdCk7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0Um9vdCA9IHRoaXMuaW5kZXhNcC5nZXQoMCk7XG4gICAgICAgIGlmIChkZWZhdWx0Um9vdCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgdGhpcy5yb290ID0gZGVmYXVsdFJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgZmFrZSByb290XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTm9kZSgtMSwtMSwtMSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIG91dHB1dCB3aG9sZSB0cmVlXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMucm9vdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG5cblxuICAgIH1cblxuICAgIHB1YmxpYyBxdWVyeSAoaW5kZXg6IG51bWJlcikge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaW5kZXhNcC5nZXQoaW5kZXgpO1xuICAgICAgICBpZiAobm9kZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZSgtMSwtMSwtMSk7XG4gICAgICAgIH0gXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn1cbiJdfQ==